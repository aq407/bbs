/*
Navicat MySQL Data Transfer

Source Server         : root
Source Server Version : 80016
Source Host           : localhost:3306
Source Database       : bbs

Target Server Type    : MYSQL
Target Server Version : 80016
File Encoding         : 65001

Date: 2020-04-28 18:03:33
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for public
-- ----------------------------
DROP TABLE IF EXISTS `public`;
CREATE TABLE `public` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `covers` varchar(255) DEFAULT NULL,
  `tag` varchar(255) DEFAULT NULL,
  `user` varchar(255) DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `synopsis` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of public
-- ----------------------------
INSERT INTO `public` VALUES ('1', 'xds', '/user/aq407/xds_covers.jpg', 'volvo', 'aq407', null, '看见你了你来看你\r\n![](G:\\java ee\\bbs\\src\\main\\resources\\static\\user\\aq407/ti.jpg)', 'nnn');
INSERT INTO `public` VALUES ('2', '第一次测试', '/user/aq407/第一次测试_covers.jpg', 'volvo', 'aq407', null, '```java\r\nSysout.out.println(\"hello world\");\r\n\r\n```\r\n\r\n![](user/aq407/太阳系.jpg)', '这是一次测试');
INSERT INTO `public` VALUES ('3', 'Java 8 Stream 的终极技巧——Collectors 操作', '/user/aq407/Java 8 Stream 的终极技巧——Collectors 操作_covers.jpg', 'opel', 'aq407', '2020-01-12 06:05:51', '# 2. Collectors 的作用\r\nCollectors 是 Java 8 加入的操作类，位于 java.util.stream 包下。它会根据不同的策略将元素收集归纳起来，比如最简单常用的是将元素装入Map、Set、List 等可变容器中。特别对于 Java 8 Stream Api 来说非常有用。它提供了collect() 方法来对 Stream 流进行终结操作派生出基于各种策略的结果集。我们就借助于 Stream 来熟悉一下 Collectors 吧。我们依然用昨天的例子：\r\n```java\r\n  List<String> servers = new ArrayList<>();\r\n        servers.add(\"Felordcn\");\r\n        servers.add(\"Tomcat\");\r\n        servers.add(\"Jetty\");\r\n        servers.add(\"Undertow\");\r\n        servers.add(\"Resin\");\r\n```\r\n# 3. Java 8 中 Collectors 的方法\r\nCollectors 提供了一系列的静态方法供我们使用，通常情况我们静态导入即可使用。接下来我们来看看都提供了哪些方法吧。\r\n我们可以根据以上提供的 API 使用 Stream 的 collect 方法中的转换为熟悉的集合容器。非常简单这里不再演示。\r\n# 3.2 joining\r\n将元素以某种规则连接起来。该方法有三种重载 joining(CharSequence delimiter) 和 joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix)\r\n```java\r\n //   输出 FelordcnTomcatJettyUndertowResin\r\n servers.stream().collect(Collectors.joining());\r\n\r\n //   输出 Felordcn,Tomcat,Jetty,Undertow,Resin\r\n servers.stream().collect(Collectors.joining(\",\" ));\r\n\r\n //   输出 [Felordcn,Tomcat,Jetty,Undertow,Resin]\r\n servers.stream().collect(Collectors.joining(\",\", \"[\", \"]\")); \r\n用的比较多的是读取 HttpServletRequest 中的 body ：\r\n\r\n  HttpServletRequest.getReader().lines().collect(Collectors.joining());\r\n```\r\n# 3.3 collectingAndThen\r\n该方法先执行了一个归纳操作，然后再对归纳的结果进行 Function 函数处理输出一个新的结果。\r\n\r\n // 比如我们将servers joining 然后转成大写，结果为： FELORDCN,TOMCAT,JETTY,UNDERTOW,RESIN\r\n `servers.stream.collect(Collectors.collectingAndThen(Collectors.joining(\",\"), String::toUpperCase));`\r\n# 3.4 groupingBy\r\n按照条件对元素进行分组，和 SQL 中的 group by 用法有异曲同工之妙，通常也建议使用 Java 进行分组处理以减轻数据库压力。groupingBy 也有三个重载方法 我们将 servers 按照长度进行分组:\r\n\r\n// 按照字符串长度进行分组    符合条件的元素将组成一个 List 映射到以条件长度为key 的` Map<Integer, List<String>> 中\r\nservers.stream.collect(Collectors.groupingBy(String::length))`\r\n如果我不想 Map 的 value 为 List 怎么办？ 上面的实现实际上调用了下面的方式：\r\n```java\r\n //Map<Integer, Set<String>>\r\n servers.stream.collect(Collectors.groupingBy(String::length, Collectors.toSet()))\r\n```\r\n我要考虑同步安全问题怎么办？ 当然使用线程安全的同步容器啊，那前两种都用不成了吧！ 别急！ 我们来推断一下，其实第二种等同于下面的写法:\r\n```java\r\n Supplier<Map<Integer,Set<String>>> mapSupplier = HashMap::new;\r\n Map<Integer,Set<String>> collect = servers.stream.collect(Collectors.groupingBy(String::length, mapSupplier, Collectors.toSet()));\r\n```\r\n这就非常好办了，我们提供一个同步 Map 不就行了，于是问题解决了：\r\n```java\r\n Supplier<Map<Integer, Set<String>>> mapSupplier = () -> Collections.synchronizedMap(new HashMap<>());\r\n Map<Integer, Set<String>> collect = servers.stream.collect(Collectors.groupingBy(String::length, mapSupplier, Collectors.toSet()));\r\n```\r\n其实同步安全问题 Collectors 的另一个方法 groupingByConcurrent 给我们提供了解决方案。用法和 groupingBy 差不多。\r\n\r\n# 3.5 partitioningBy\r\npartitioningBy 我们在本文开头的提到的文章中已经见识过了，可以看作 groupingBy 的一个特例，基于断言（Predicate）策略分组。这里不再举例说明。\r\n\r\n3.6 counting\r\n该方法归纳元素的的数量，非常简单，不再举例说明。\r\n\r\n3.7 maxBy/minBy\r\n这两个方法分别提供了查找大小元素的操作，它们基于比较器接口 Comparator 来比较 ，返回的是一个 Optional 对象。 我们来获取 servers 中最小长度的元素:\r\n```java\r\n // Jetty  \r\nOptional<String> min = servers.stream.collect(Collectors.minBy(Comparator.comparingInt(String::length)));\r\n```\r\n这里其实 Resin 长度也是最小，这里遵循了 \"先入为主\" 的原则 。当然 Stream.min() 可以很方便的获取最小长度的元素。maxBy 同样的道理。\r\n\r\n# 3.8 summingInt/Double/Long\r\n用来做累加计算。计算元素某个属性的总和,类似 Mysql 的 sum 函数，比如计算各个项目的盈利总和、计算本月的全部工资总和等等。我们这里就计算一下 servers 中字符串的长度之和 （为了举例不考虑其它写法）。\r\n```java\r\n // 总长度 32\r\n servers.stream.collect(Collectors.summingInt(s -> s.length()));\r\n```\r\n# 3.9 summarizingInt/Double/Long\r\n如果我们对 3.6章节-3.8章节 的操作结果都要怎么办？难不成我们搞5个 Stream 流吗？ 所以就有了 summarizingInt、summarizingDouble、summarizingLong 三个方法。 这三个方法通过对元素某个属性的提取，会返回对元素该属性的统计数据对象，分别对应 IntSummaryStatistics、DoubleSummaryStatistics、LongSummaryStatistics。我们对 servers 中元素的长度进行统计：\r\n```java\r\n DoubleSummaryStatistics doubleSummaryStatistics = servers.stream.collect(Collectors.summarizingDouble(String::length));\r\n  // {count=5, sum=32.000000, min=5.000000, average=6.400000, max=8.000000}\r\n  System.out.println(\"doubleSummaryStatistics.toString() = \" + doubleSummaryStatistics.toString());\r\n```\r\n结果 DoubleSummaryStatistics 中包含了 总数，总和，最小值，最大值，平均值 五个指标。\r\n\r\n# 3.10 mapping\r\n该方法是先对元素使用 Function 进行再加工操作，然后用另一个Collector 归纳。比如我们先去掉 servers 中元素的首字母，然后将它们装入 List 。\r\n```java\r\n // [elordcn, omcat, etty, ndertow, esin]\r\n servers.stream.collect(Collectors.mapping(s -> s.substring(1), Collectors.toList()));\r\n```\r\n有点类似 Stream 先进行了 map 操作再进行 collect ：\r\n```java\r\n servers.stream.map(s -> s.substring(1)).collect(Collectors.toList());\r\n```\r\n\r\n\r\n\r\n', '昨天在 Collection移除元素操作 相关的文章中提到了 Collectors 。相信很多同学对这个比较感兴趣，那我们今天就来研究一下 Collectors 。');
INSERT INTO `public` VALUES ('4', '为什么很多人不愿意用hibernate了', '/user/aq407/为什么很多人不愿意用hibernate了_covers.jpg', '编程', 'aq407', '2020-01-14 15:03:03', '### 一、hibernate优势\r\nhibernate让你不用写sql了，这不单可以让你的应用更好移植其它数据库，更主要的是让程序员更专注业务逻辑、数据关系、对象关系等。hibernate对一对多，多对多关系实现是非常好的。很关键一点，它支持lazy，可以让你的数据只在需要的时候被加载，听起来很完美。hibernate还有一个更牛的就是HQL，这是完全可以把查询映射到你OO模型的查询语言，和mybatis的映射比起来，还是更方便和更强大的。\r\n**1、@Lazy注解是什么?**\r\n\r\n@Lazy注解用于标识bean是否需要延迟加载，源码如下：\r\n\r\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.FIELD})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\npublic @interface Lazy {\r\n    /**\r\n     * Whether lazy initialization should occur.\r\n     */\r\n    boolean value() default true;\r\n}\r\n只有一个参数，默认是true，也就是说只要加了这个注解就会延迟加载。\r\n\r\n**2、@Lazy注解怎么使用**\r\n\r\n没加注解之前主要容器启动就会实例化bean，如下：\r\n\r\nAnnotationConfigApplicationContext applicationContext2 = new AnnotationConfigApplicationContext(MainConfig.class);\r\n创建user实例\r\n\r\n而加上@Lazy注解则必须在第一次调用的时候才会加载如下：\r\n\r\n@Scope\r\n@Lazy\r\n@Bean(value=\"user0\",name=\"user0\",initMethod=\"initUser\",destroyMethod=\"destroyUser\")\r\npublic User getUser(){\r\n    System.out.println(\"创建user实例\");\r\n    return new User(\"张三\",26);\r\n}\r\nAnnotationConfigApplicationContext applicationContext2 = new AnnotationConfigApplicationContext(MainConfig.class);\r\nUser bean2 = applicationContext2.getBean(User.class);\r\n创建user实例\r\n实例1 === User [userName=张三, age=26]\r\n@Lazy注解注解的作用主要是减少springIOC容器启动的加载时间\r\n\r\n### 二、hibernate劣势\r\n\r\n看完优势之后，感觉hibernate无所不能了，无敌是多么的寂寞。处理大量数据或者大并发情况的网络服务感觉不是很好用，那么现在开始说说hibernate的问题。\r\n\r\n1、难以使用数据库的一些功能\r\n\r\nhibernate将数据库与开发者隔离了，开发者不需要关注数据库是Oracle还是MySQL，hibernate来帮你生成查询的sql语句，但问题来了，如果你想用某种数据库特有的功能，或者要让查询的sql完全符合你的心意，这就难了。如果使用hibernate，虽然它能对生成的查询进行一定程序的定制，但就有点隔靴挠痒的感觉了，而且你开发起来付出的代价更大。至于hibernate对native sql的支持，还是挺完善的，这种native sql还能返回non-managed entity，不走hibernate的cache，优化是搞定了，但如果整个项目都这么整，那还是用mybatis吧。\r\n\r\n很多时候，我们都有一个需求：得到数据库服务器的当前时间。这是因为本机时间和服务器时间是有差别的。各种数据库都提供了函数来获得，比如，mysql，可以用“select now()”。hibernate也提供了一个函数current_timestamp（说起timestamp，个人认为数据库的timestamp做的很差，它居然和datetime是一个数量级的（精确度），这怎么可以用来表示真正的stamp啊！）。可是，你却无法用直接使用“select current_timestamp()”来获得服务器的当前时间，你还必须加上一个查询的表！比如，“select current_timestamp() from tbl_Good”。个人十分郁闷，我只是想用这个简单功能而已，为什么我一定要知道数据库里面的表格呢？？？？更何况还必须建立映射。。。。。。\r\n\r\n不是我不明白，这世界太复杂了 。每样产品都是拼命的复杂化，其实，它们实在是忽略了一般的用户只需要一小部分功能而已。默认的功能应该是能够满足普通用户的常见需求的，那样才算是一个好的产品。我不认为hibernate做到了这点。\r\n\r\n2、满足不了程序对cache的需求\r\n\r\n很多web服务，对cache的依赖是非常大的，hibernate自带的cache按理说也是很强大的，但还是满足不了很多需求。\r\n\r\n### 3、耦合度高\r\n\r\nhibernate的确是在你项目开发的时候节约了很多时间，但是它对你的业务逻辑模型和数据库模型互相依赖的程序太高了。短期没啥问题，但随着项目的变迁，这些都会改变，在维持这种仅仅耦合的关系的时候，你会发信你的代码特别脆弱，随便改一处数据库的schema，整个java项目可能要改几十次。而且现在mybatis的自动mapping做的也很好，开发起来也没花多长时间，等项目进入中后期，你需要大量定制和优化查询的时候，mybatis的开发效率就更明显了。\r\n\r\n### 4、debug难\r\n\r\n作为一个后端程序员，我比较喜欢每一行代码我都精确知道它到底在干什么。尤其是数据库访问的代码，往往系统的瓶颈就在这些地方产生，每一行都不能小看。我看过hibernate早期版本的部分代码，比我想象的复杂和强大很多。的确很多地方Hibernate可以强大的只用一行代码解决很多问题，但比如说一个update()或者save()到底做了什么，这里既有hibernate本身的逻辑，也有你应用的逻辑，如果这一行产生了问题，你该如何去做？我个人觉得这是很难搞的，还不如一开始费点事，用mybatis这种。\r\n\r\n作为一个程序员，我始终坚持认为改代码比改配置文件容易。\r\n\r\n5、hibernate更新大批量数据\r\n\r\n（1）hibernate批量更新customers表中大于零的所有记录的age字段：\r\n\r\nTransaction transaction = session.beginTransaction();     \r\nIterator customers=session.find(\"from Customer c where c.age>0\").iterator();     \r\nwhile(customers.hasNext()){     \r\n    Customer customer=(Customer)customers.next();     \r\n    customer.setAge(customer.getAge()+1);     \r\n}      \r\ntransaction.commit();     \r\nsession.close();  \r\n如果customers表中有一万条年龄大于零的记录，那么session的find()方法会一下子加载一万个customer对象到内存中。当执行tx.commit()方法时，会清理缓存，hibernate执行一万条更新customers表的update语句：\r\n\r\nupdate CUSTOMERS set AGE=? …. where ID=i;     \r\n（2）以上hibernate批量更新方式有两个缺点\r\n\r\n占用大量内存空间，必须把一万个customer对象先加载到内存，然后一一更新他们。\r\n执行的update语句的数目太多，每个update语句只能更新一个Customer对象，必须通过1万条update语句才能更新一万个Customer对象，频繁的访问数据库，会大大降低应用的性能。\r\n（3）为了迅速释放1万个Customer对象占用的内存，可以在更新每个Customer对象后，就调用Session的evict()方法立即释放它的内存：\r\n```java\r\nTransaction transaction = session.beginTransaction();\r\nIterator customers=session.find(\"from Customer c where c.age>0\").iterator();\r\nwhile(customers.hasNext()){\r\n    Customer customer=(Customer)customers.next();\r\n    customer.setAge(customer.getAge()+1);\r\n    session.flush();\r\n    session.evict(customer);\r\n}\r\ntransaction.commit();\r\nsession.close();\r\n```\r\n在以上程序中，修改了一个Customer对象的age属性后，就立即调用Session的flush()方法和evict()方法，flush()方法使hibernate立刻根据这个Customer对象的状态变化同步更新数据库，从而立即执行相关的update()语句；evict()方法用于把这个Customer对象从缓存中清除出去，从而及时释放它占用的内存。\r\n\r\n但evict()方法只能稍微提高批量操作的性能，因为不管有没有使用evict()方法，Hibernate都必须执行1万条update语句，才能更新1万个Customer对象，这是影响批量操作性能的重要因素。假如Hibernate能直接执行如下SQL语句：\r\n\r\nupdate CUSTOMERS set AGEAGE=AGE+1 where AGE>0;   \r\n那么以上一条update语句就能更新CUSTOMERS表中的1万条记录。但是Hibernate并没有直接提供执行这种update语句的接口。应用程序必须绕过Hibernate API，直接通过JDBC API来执行该SQL语句：\r\n```java\r\nTransaction transaction = session.beginTransaction();     \r\nConnection con=session.connection();     \r\nPreparedStatement stmt=con.prepareStatement(\"update CUSTOMERS set AGEAGE=AGE+1 where AGE>0 \");     \r\nstmt.executeUpdate();     \r\ntransaction.commit();  \r\n```\r\n以上程序演示了绕过Hibernate API，直接通过JDBC API访问数据库的过程。应用程序通过Session的connection()方法获得该Session使用的数据库连接，然后通过它创建 PreparedStatement对象并执行SQL语句。值得注意的是，应用程序仍然通过Hibernate的Transaction接口来声明事务边 界。 \r\n如果底层数据库（如Oracle）支持存储过程，也可以通过存储过程来执行Hibernate批量更新。存储过程直接在数据库中运行，速度更加快。在Oracle数据库中可以定义一个名为batchUpdateCustomer()的存储过程，代码如下：\r\n```java\r\ncreate or replace procedure batchUpdateCustomer(p_age in number) as     \r\nbegin     \r\nupdate CUSTOMERS set AGEAGE=AGE+1 where AGE>p_age;     \r\nend;  \r\n```\r\n以上存储过程有一个参数p_age，代表客户的年龄，应用程序可按照以下方式调用存储过程：\r\n```java\r\nTransaction transaction = session.beginTransaction();     \r\nConnection con=session.connection();     \r\nString procedure = \"{call batchUpdateCustomer(?) }\";     \r\nCallableStatement cstmt = con.prepareCall(procedure);     \r\ncstmt.setInt(1,0); //把年龄参数设为0     \r\ncstmt.executeUpdate();     \r\ntransaction.commit(); \r\n```\r\n从上面程序看出，应用程序也必须绕过Hibernate API，直接通过JDBC API来调用存储过程。 \r\n\r\n**6、hibernate删除大批量数据**\r\n\r\nSession的各种重载形式的update()方法都一次只能更新一个对象，而delete()方法的有些重载形式允许以HQL语句作为参数，例如：\r\n\r\n`session.delete(\"from Customer c where c.age>0\"); ` \r\n如果CUSTOMERS表中有1万条年龄大于零的记录，那么以上代码能删除一万条记录。但是Session的delete()方法并没有执行以下delete语句\r\n\r\n`delete from CUSTOMERS where AGE>0;`\r\nSession的delete()方法先通过以下select语句把1万个Customer对象加载到内存中：\r\n\r\n`select * from CUSTOMERS where AGE>0;`  \r\n接下来执行一万条delete语句，逐个删除Customer对象：\r\n```\r\ndelete from CUSTOMERS where ID=i;     \r\ndelete from CUSTOMERS where ID=j;     \r\ndelete from CUSTOMERS where ID=k;  \r\n```\r\n由 此可见，直接通过Hibernate API进行Hibernate批量更新和Hibernate批量删除都不值得推荐。而直接通过JDBC API执行相关的SQL语句或调用存储过程，是hibernate批量更新和批量删除的最佳方式。', '关于SQL和ORM的争论，永远都不会终止，我也一直在思考这个问题。最近温习了一遍SSH框架，发了动弹，和广大猿友进行了深刻的探讨，被喷的五体投地，感慨万千，于是就有了今天这篇文章。\r\n\r\n声明：本文只是小编的一点拙见，不喜勿喷。');
INSERT INTO `public` VALUES ('5', 'Kotlin 1.4 和未来值得期待的地方', '/user/aq407/Kotlin 1.4 和未来值得期待的地方_covers.jpg', '编程', 'aq407', '2020-01-15 14:48:16', '### 新的编译器\r\n新编译器实现的目标是变得更快速、统一 Kotlin 支持的所有平台，并提供用于编译器扩展的 API。这将是一项多年的工作，不过开发团队已开始好一阵子了，因此新实现的某些部分将在 1.4 中发布，可让这个过程变得更加平顺。\r\n\r\n有些功能也已经发布了； 例如，如果开发者尝试了用于类型推理的新算法，它是新编译器的一部分。其他部分的处理方法相同。 也就是说，两种版本都将在一段时间内可用，旧版本和新版本都将处于实验模式； 当新的稳定后，它将成为默认版本。\r\n\r\n### 新的前端（front-end）加速\r\n开发团队期望新编译器提高的速度将来自新的前端实现。\r\n\r\n为了提供一些背景信息，可以将编译想成吸收源文件并将其逐步转换为可执行代码的管道。此管道的第一步俗称为编译器的前端。它解析代码和命名、执行类型检查等。此编译器的这一部分也可以在 IDE 中使用，来高亮显示语法错误、导航到定义并搜索项目中的符号用法。这是 kotlinc 如今花费最多时间的步骤，因此开发团队希望使其更快。\r\n\r\n当前的实现尚未完成，并且不会在 1.4 中到来。 但是，大多耗时的工作都是由它完成，因此可以预期提速的效果。基准测试（编译 YouTrack 和 Kotlin 编译器本身）表明，新前端的速度约为现有前端快 4.5 倍。\r\n\r\n### 统一的后端和可扩展性\r\n在前端完成对代码的分析之后，后端将生成可执行文件。目前有三个后端：Kotlin / JVM，Kotlin / JS 和 Kotlin / Native。前两个以往是独立编写的，没有代码共享。当启动 Kotlin / Native 时，它是基于围绕 Kotlin 代码内部表示（internal representation）构建的新基础架构的，该功能具有与虚拟机中的字节码类似的功能。\r\n\r\n现在，开发团队计划将其他两个后端迁移到同一内部表示。因此，他们将共享许多后端逻辑并拥有统一的管道，以允许对所有目标仅执行一次大多数功能、优化和错误修复。\r\n\r\n虽然正逐步迁移到新的后端，可是在 1.4 中，默认情况下不太可能启用它们，但用户将能够选择明确使用它们。\r\n\r\n通用的后端基础结构为跨平台编译器扩展打开了大门。可以在这管道中添加一些自定义处理和/或转换，这些处理和转换将自动适用于所有目标。在 1.4 中将不提供用于此类扩展的公开 API（该 API 稍后将被稳定），但开发团队正在与合作伙伴 （其中包括已经构建其编译器插件的 JetPack Compose ）紧密合作。\r\n\r\n### 新的语言功能：\r\nKotlin 1.4 将提供一些新的语言功能。\r\n\r\nKotlin 类的 SAM 转换\r\n社区已要求开发团队引入对 Kotlin 类（ KT-7770 ）的 SAM 转换的支持。如果仅将一个抽象方法的接口或类预计作为参数，则将 lambda 作为参数传递时，将应用 SAM 转换。然后，编译器自动将 lambda 转换为实现抽象成员函数的类的实例。\r\n\r\nSAM 转换当前仅适用于 Java 接口和抽象类。该设计背后的最初想法是针对此类用例明确使用函数类型。然而，事实证明，函数类型和类型别名并不能涵盖所有用例，开发者常常不得不仅在 Java 中保留接口才能对其进行 SAM 转换。\r\n\r\n与 Java 不同，Kotlin 不允许使用一种抽象方法对每个接口进行 SAM 转换。开发团队认为，使接口适用于 SAM 转换的意图应该明确。因此，要定义 SAM 接口，开发者需要使用 fun 关键字标记一个接口，以强调它可以用作功能性接口：\r\n```\r\nfun interface Action {\r\n    fun run()\r\n}\r\n \r\nfun runAction(a: Action) = a.run()\r\n \r\nfun main() {\r\n    runAction {\r\n        println(\"Hello, KotlinConf!\")\r\n    }\r\n}\r\n```\r\n请注意，仅在新的类型推断算法中支持传递 lambda 而不是 fun 接口。\r\n\r\n混合命名和位置参数\r\nKotlin 禁止将带有显式名称的参数（“命名”）和不带名称的常规参数（“位置”）混合使用，除非仅将命名参数放在所有位置参数之后。但是，在一种情况下，这确实很烦人：当所有参数都保持在正确的位置而您想为中间的一个参数指定名称时。Kotlin 1.4 将解决此问题，因此将能够编写如下代码：\r\n```\r\nfun f(a: Int, b: Int, c: Int) {}\r\n \r\nfun main() {\r\n    f(1, b = 2, 3)\r\n}\r\n```\r\n优化的委托属性\r\n开发团队将改进 lazy 属性和其他一些委托属性的编译方式。\r\n\r\n通常，委托属性可以访问相应的 KProperty 反射对象。例如，当使用 Delegates.observable 时，可以显示有关已修改属性的信息：\r\n```\r\nimport kotlin.properties.Delegates\r\n \r\nclass MyClass {\r\n    var myProp: String by Delegates.observable(\"<no name>\") {\r\n        kProperty, oldValue, newValue ->\r\n        println(\"${kProperty.name}: $oldValue -> $newValue\")\r\n    }\r\n}\r\n \r\nfun main() {\r\n    val user = MyClass()\r\n    user.myProp = \"first\"\r\n    user.myProp = \"second\"\r\n}\r\n```\r\n为了使之成为可能，Kotlin 编译器会生成一个附加的语法成员属性，即一个存储所有 KProperty 对象的数组，这些对象表示在类内部使用的委托属性：\r\n```\r\n>>> javap MyClass\r\n \r\npublic final class MyClass {\r\n    static final kotlin.reflect.KProperty[] $$delegatedProperties;\r\n    ...\r\n}\r\n```\r\n但是，某些委托属性不会以任何方式使用 KProperty。对于他们来说，在 $$delegatedProperties 中生成对象是次优的。Kotlin 1.4 版本将优化这种情况。如果委托属性运算符是 inline，并且未使用 KProperty 参数，则不会生成相应的反射对象。最出色的示例是 lazy 属性。lazy 属性的 getValue 实现是 inline，并且不使用 KProperty 参数：\r\n\r\n`inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value`\r\n从 Kotlin 1.4 开始，当定义 lazy属性时，将不会生成相应的 KProperty实例。如果在类中使用的唯一委托属性是 lazy属性（以及符合此优化的其他属性），则不会为类生成整个 $$delegatedProperties 数组：\r\n```\r\nclass MyOtherClass {\r\n    val lazyProp by lazy { 42 }\r\n}\r\n\r\n>>> javap MyOtherClass\r\npublic final class MyOtherClass {\r\n    // no longer generated:\r\n    static final kotlin.reflect.KProperty[] $$delegatedProperties; \r\n    ...\r\n}\r\n```\r\n尾随逗号\r\n可以在参数列表中的最后一个参数之后放置一个附加的尾随逗号，然后交换行或添加新参数，而不必添加或删除丢失的逗号。\r\n\r\n其他主要变化\r\nKotlin 1.3.40 中引入了的有用的 typeof 函数将变得稳定并在所有平台上得到支持。\r\n1.3.60 版本博客文章中已经描述了使您可以在 when 内启用 break 和 continue 的功能。', 'Kotlin 1.4 将于 2020 年春季推出，其开发团队在博客介绍了他们对 Kotlin 的愿景：“让 Kotlin 成为您所有工作的可靠伴侣，并是您执行任务的默认语言选择。”因此，开发团队将会让开发者在所有平台上都能使用 Kotlin。');
INSERT INTO `public` VALUES ('6', 'SpringBoot有啥高科技', '/user/aq407/SpringBoot有啥高科技_covers.jpg', '编程', 'aq407', '2020-01-15 15:00:07', '### 1.SpringMvc XML配置\r\n说到配置SpringMvc，大家第一时间反应就是xml配置，目前国内的各类博客或者各类老师都是套用这种方式，一直都是认为这种方式是唯一的方式，再说Spring官方一直支持。\r\n\r\n### 1.1 配置web.xml\r\nweb.xml是servlet容器的配置文件，当启动一个WEB项目时，servlet容器首先会读取项目中的webapp/WEB-INFO文件夹的web.xml配置文件里的配置,主要用来配置监听器listener，servlet，上下文参数context-param。\r\n\r\n    <!-- 配置监听器 -->      \r\n    <listener>\r\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n    <!-- 配置DispatcherServlet -->  \r\n    <servlet>  \r\n    　　<servlet-name>dispatcherServlet</servlet-name>  \r\n    　　<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  </servlet>\r\n    <!-- ServletContext参数 -->  \r\n  	 <context-param>\r\n      <param-name>contextConfigLocation</param-name>\r\n      <param-value>/WEB-INF/spring-config/*.xml</param-value>\r\n   	</context-param>\r\n\r\nContextLoaderListener(上下文加载监听) 继承了ServletContextListener(Servlet上下文监听)，当ServletContext的生命周期发生变化会触发相应的事件\r\n\r\n通过这个监听器进来的会通过createWebApplicationContext获取ConfigurableWebApplicationContext\r\n\r\n具体代码：  ContextLoader ->configureAndRefreshWebApplicationContext方法\r\n```\r\n  protected void configureAndRefreshWebApplicationContext\r\n        (ConfigurableWebApplicationContext wac, ServletContext sc) {\r\n    //添加ServletContext\r\n	wac.setServletContext(sc);\r\n	String configLocationParam = sc.getInitParameter(\"contextConfigLocation\");\r\n   //添加Spring*.xml\r\n	wac.setConfigLocation(configLocationParam);\r\n    customizeContext(sc, wac);\r\n	//读取配置加载，刷新Spring上下文\r\n    wac.refresh();\r\n  }\r\nDispatcherServlet 用来接收SpringMVC所有请求的servlet程序，会注册到ServletContext中。\r\n```\r\n### 1.2 配置applicationContext.xml\r\n主要扫描业务类，AOP切面配置，事务配置，数据源配置等\r\n```\r\n<!--扫描包注解   不扫描@controller-->\r\n<context:component-scan base-package=\"com.wangnian\">\r\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\r\n</context:component-scan> \r\n```\r\n### 1.3 配置springmvc.xml\r\n主要扫描Controller，拦截器，视图转换等\r\n```\r\n<!--扫描包注解  只扫描@Controller-->\r\n<context:component-scan base-package=\"com.wangnian.controller\" >\r\n	   <context:include-filter type=\"annotation\"  expression=\"org.springframework.stereotype.Controller\" />\r\n</context:component-scan>  \r\n```\r\n### 1.4 启动大概流程\r\n在启动Servlet容器，会去读取web.xml配置文件注册Servlet，然后异步执行ServletContextListener的contextInitialized方法读取用户自定义的xml配置文件并创建bean，刷新Spring上下文。\r\n\r\n \r\n2.SpringMvc 另外一种配置\r\n2.1 怎么注册DispatcherServlet ？\r\n猜想1：也是xml配置方式。但是Spring官网都把零xml的配置当成一种优势，那显然不科学。\r\n\r\n猜想2：@WebServlet。我们找找DispatcherServlet这个类?居然没有@WebServlet注解\r\n\r\n那只能看看SpringMvc的文档，发现SpringMvc官方配置也推荐使用javaConfig的配置方式。\r\n\r\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\r\n\r\n具体代码：\r\n```\r\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\r\n\r\n    @Override\r\n    public void onStartup(ServletContext servletContext) throws ServletException {\r\n        //SpringWeb注解配置应用程序上下本\r\n        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();\r\n        //注册带有注解的类\r\n        ac.register(AppConfig.class);\r\n        //spring上下文刷新\r\n        ac.refresh();\r\n\r\n        //创建DispatcherServlet\r\n        DispatcherServlet servlet = new DispatcherServlet(ac);\r\n\r\n        //servlet中注册DispatcherServlet\r\n        ServletRegistration.Dynamic registration = servletContext.addServlet(\"app\", servlet);\r\n        registration.setLoadOnStartup(1);\r\n        registration.addMapping(\"/app/*\");\r\n    }\r\n}\r\n```\r\n我们发现这个自定义类会实现WebApplicationInitializer接口\r\n\r\nonStartup方法会拿到tomcat传过来的ServletContext（如果是jetty 就是jetty提供的   如果是tomcat 就是 tomcat提供的）\r\n\r\nAnnotationConfigWebApplicationContext是继承了上面的ConfigurableWebApplicationContext ，用来实例化IOC容器，也就是做Spring上下文刷新的，\r\n\r\n它不仅支持扫描@Configuration注解，任何@Compnent注解的类或者 按照JSR-330注解的类都被支持 。\r\n\r\nAppConfig类上会加入@ComponentSan注解，扫描指定包下所有的业务层和控制层的bean\r\n\r\n而我们之前的xml配置的DispatcherServlet是通过new DispatcherServlet()出来的\r\n\r\n \r\n\r\n### 2.2 onStartup啥时候能调到？\r\n传统配置的web.xml 是在servlet容器启动的时候加载的，那实现webApplicationInitializer的自定义的类应该也要在servlet容器启动的时候被加载到\r\n\r\n是不是tomcat也学Spring一样得到所有WebApplicationInitializer的实现，然后调用它的onStartup呢。\r\n\r\n但是他们工程师绝对不会这么干，因为WebApplicationInitializer是Spring提供的，一个实现Servlet规范的容器不可能依赖Spring的jar包。\r\n\r\n那接下来我们来看看SpringMvc的启动核心科技\r\n\r\n首先tomcat是一个Servlet容器，遵循并实现了Servlet的规范，tomcat7之后是3.0的，在3.0的有个新的特性\r\n\r\n就是它 ：ServletContainerInitializer（Servlet容器初始化器）\r\n\r\n在web容器启动时为提供给第三方组件做一些初始化的工作，例如注册servlet或者listener等。\r\n\r\n前提是必须在对应的jar包的META-INF/services 目录创建一个名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类\r\n\r\n一般伴随着ServletContainerInitializer一起使用的还有@HandlesTypes注解，他会在调用onStartup方法的时候会把所有实现的类集合传给你。\r\n\r\n具体代码：   SpringServletContainerInitializer->onStartup\r\n```\r\n@Override\r\n	public void onStartup(@Nullable Set<Class<?>> webAppInitializerClasses, ServletContext servletContext)\r\n			throws ServletException {\r\n        //一个装WebApplicationInitializer实现的集合\r\n		List<WebApplicationInitializer> initializers = new LinkedList<>();\r\n		for (Class<?> waiClass : webAppInitializerClasses) {\r\n            //通过反射拿到HandlesTypes注解指定的class的实现类\r\n			initializers.add(ReflectionUtils.accessibleConstructor(waiClass).newInstance());\r\n		}\r\n        //进行排序\r\n		AnnotationAwareOrderComparator.sort(initializers);\r\n        //循环调用所有集合里的onStartup方法\r\n		for (WebApplicationInitializer initializer : initializers) {\r\n			initializer.onStartup(servletContext);\r\n		}\r\n	}\r\n这是spring惯用方法，将所有实现WebApplicationInitializer的实现类，遍历执行onStartup方法\r\n\r\n大家看到这里是不是就大概清楚SpringBoot是怎么才能做到零配置的。\r\n\r\n```\r\n\r\n3.SpringBoot具体是怎么配置的SpringMvc\r\n在Spring代码中有一个DispatcherServletAutoConfiguration静态类，声明了一个DispatcherServlet的Bean\r\n\r\n具体代码：DispatcherServletAutoConfiguration\r\n```\r\nprotected static class DispatcherServletConfiguration {\r\n\r\n		@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\r\n		public DispatcherServlet dispatcherServlet(HttpProperties httpProperties, WebMvcProperties webMvcProperties) {\r\n			DispatcherServlet dispatcherServlet = new DispatcherServlet();\r\n			dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());\r\n			dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());\r\n			dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());\r\n			dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());\r\n			dispatcherServlet.setEnableLoggingRequestDetails(httpProperties.isLogRequestDetails());\r\n			return dispatcherServlet;\r\n		}\r\n}\r\n```\r\n这里就需要借助一下SpringBoot启动流程\r\n\r\nmain方法启动之后首先会检查是否是web项目，怎么检查呢？\r\n\r\n对的 大家猜的对，就是尝试forName（加载类）加载一下初始化这个写死的类路径javax.servlet.Servlet，如果能实例化就代表是。\r\n\r\n具体代码：WebApplicationType\r\n```\r\nif (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\r\n      && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\r\n   return WebApplicationType.REACTIVE;\r\n}\r\nfor (String className : SERVLET_INDICATOR_CLASSES) {\r\n   if (!ClassUtils.isPresent(className, null)) {\r\n      return WebApplicationType.NONE;\r\n   }\r\n}\r\n```\r\nreturn WebApplicationType.SERVLET;\r\n如果是Servlet环境就会使用AnnotationConfigServletWebServerApplicationContext去刷新spring上下文\r\n\r\n这样DispatcherServlet被作为一个普通Bean被实例化并注册到IOC容器中。\r\n\r\n在调用刷新spring上下文之后调用createWebServer方法\r\n```\r\n	@Override\r\n	protected void onRefresh() {\r\n		super.onRefresh();\r\n		try {\r\n			createWebServer();\r\n		}\r\n		catch (Throwable ex) {\r\n			throw new ApplicationContextException(\"Unable to start web server\", ex);\r\n		}\r\n	}\r\n```\r\n```\r\ncreateWebServer()\r\n\r\nprivate void createWebServer() {\r\n   WebServer webServer = this.webServer;\r\n   ServletContext servletContext = getServletContext();\r\n   if (webServer == null && servletContext == null) {\r\n      ServletWebServerFactory factory = getWebServerFactory();\r\n      //根据工厂模式调用对应的servlet实现的容器，如果是tomcat就调用TomcatServletWebServerFactory的getWebServer()\r\n      this.webServer = factory.getWebServer(getSelfInitializer());\r\n   }\r\n   else if (servletContext != null) {\r\n      try {\r\n         getSelfInitializer().onStartup(servletContext);\r\n      }\r\n      catch (ServletException ex) {\r\n         throw new ApplicationContextException(\"Cannot initialize servlet context\", ex);\r\n      }\r\n   }\r\n   initPropertySources();\r\n}\r\n```\r\n创建tomcat实例并启动\r\n```\r\n@Override\r\n	public WebServer getWebServer(ServletContextInitializer... initializers) {\r\n		if (this.disableMBeanRegistry) {\r\n			Registry.disableRegistry();\r\n		}\r\n		Tomcat tomcat = new Tomcat();\r\n		File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");\r\n		tomcat.setBaseDir(baseDir.getAbsolutePath());\r\n		Connector connector = new Connector(this.protocol);\r\n		connector.setThrowOnFailure(true);\r\n		tomcat.getService().addConnector(connector);\r\n		customizeConnector(connector);\r\n		tomcat.setConnector(connector);\r\n		tomcat.getHost().setAutoDeploy(false);\r\n		configureEngine(tomcat.getEngine());\r\n		for (Connector additionalConnector : this.additionalTomcatConnectors) {\r\n			tomcat.getService().addConnector(additionalConnector);\r\n		}\r\n        //准备上下文，主要会提前放入他自己的ServletContextInitializer(Servlet上下文是初始化器)\r\n        //实现类，供SpringBoot在ServletContainerInitializer的onStartup()里遍历调用自己的onStartup()\r\n        //为了注册用户自定义的Filter和Servlet到ServletContext中\r\n		prepareContext(tomcat.getHost(), initializers);\r\n        //启动tomcat\r\n		return getTomcatWebServer(tomcat);\r\n	}\r\n```\r\n\r\n 具体代码：\r\n```\r\n org.springframework.boot.web.embedded.tomcat.TomcatWebServer ->initialize();\r\n\r\nprivate void initialize() throws WebServerException {\r\n	// Start the server to trigger initialization listeners\r\n	this.tomcat.start();\r\n}\r\n```\r\n在这时候按照servlet3.0的标准，Tomcat启动的时候会调用ServletContainerInitializer（Servlet容器初始化器）所有实现类的onStartup()方法\r\n\r\n具体代码：TomcatStarter->onStartup();\r\n```\r\n@Override\r\npublic void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {\r\n   \r\n   for (ServletContextInitializer initializer : this.initializers) {\r\n         initializer.onStartup(servletContext);\r\n   }\r\n   \r\n}\r\n```\r\n具体代码：ServletRegistrationBean->onStartup(); \r\n```\r\n@Override\r\npublic final void onStartup(ServletContext servletContext) throws ServletException {\r\n   String description = getDescription();\r\n   if (!isEnabled()) {\r\n      logger.info(StringUtils.capitalize(description) + \" was not registered (disabled)\");\r\n      return;\r\n   }\r\n   //拿到Tomcat传过来的ServletContext进行注册\r\n   register(description, servletContext);\r\n}\r\n```\r\n具体代码：ServletRegistrationBean->addRegistration(); \r\n```\r\n@Override\r\nprotected ServletRegistration.Dynamic addRegistration(String description, ServletContext servletContext) {\r\n   String name = getServletName();\r\n   return servletContext.addServlet(name, this.servlet);\r\n}\r\n```\r\n这样 DispatcherServlet 就注册进去了。\r\n\r\n这也为啥SpringBoot只支持Servlet3.0的容器，只不过赶上了3.0的好特性，才让我们开发者体验到非常友善的傻白甜的开发。\r\n\r\n \r\n### 4.扩展\r\n首先SpringBoot有两种部署方式  丢Tomcat和java -jar运行。\r\n\r\n对于两种，它的启动的也不一样\r\n\r\n4.1 SpringBoot内置的容器\r\n首先Springboot并不是web应用，在你只引入\r\n```\r\n<dependency>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-starter</artifactId>\r\n  <version>2.1.6.RELEASE</version>\r\n  <scope>compile</scope>\r\n</dependency>\r\n```\r\n它只不过是一个Spring的项目\r\n\r\n那官方说的内置servlet容器，默认使用的tomcat是谁引进来的？\r\n\r\n如果是web项目就必须得引入spring-boot-starter-web，而它依赖了spring-boot-starter-tomcat\r\n```\r\n<dependency>\r\n  <groupId>org.apache.tomcat.embed</groupId>\r\n  <artifactId>tomcat-embed-core</artifactId>\r\n  <version>9.0.21</version>\r\n  <scope>compile</scope>\r\n  <exclusions>\r\n    <exclusion>\r\n      <artifactId>tomcat-annotations-api</artifactId>\r\n      <groupId>org.apache.tomcat</groupId>\r\n    </exclusion>\r\n  </exclusions>\r\n</dependency>\r\n```\r\n4.2丢war包的方式\r\n配置很简单，只需要继承SpringBootServletInitializer，而SpringBootServletInitializer实现了WebApplicationInitializer接口\r\n```\r\npackage com.example;\r\n\r\nimport org.springframework.boot.builder.SpringApplicationBuilder;\r\nimport org.springframework.boot.context.web.SpringBootServletInitializer;\r\npublic class SpringBootServletStart extends SpringBootServletInitializer {  \r\n  \r\n    @Override  \r\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\r\n        //这里是@SpringBootApplication类\r\n        return application.sources(DemoApplication.class);\r\n    }  \r\n  \r\n}  \r\n```\r\n这种方式和SpringMvc的javaConfig一样方式，tomcat启动的时候去找WebApplicationInitializer的实现类\r\n\r\n当执行到SpringBootServletInitializer的onStartup方法的时候，new SpringBootApplication.run()\r\n\r\n### 4.3  java -jar运行\r\nmaven  package打的jar是不能直接运行的。\r\n\r\n为啥我们 maven package一下就可以，那是因为SpringBoot项目都有一个插件\r\n```\r\n <plugin>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-maven-plugin</artifactId>\r\n  </plugin>\r\nmvn package spring-boot:repackage\r\n```\r\n所以SpringBoot 打完包在tagger里看到两个，一个是.jar.original  一个是.jar ，也就是说Maven首先在package阶段打包生成*.jar文件；然后执行spring-boot:repackage重新打包，会把项目运行的所有依赖的jar包都整合到一个单独的jar包中，并配置Manifest文件以及JarLauncher\r\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins.html#build-tool-plugins-maven-plugin\r\n```\r\nManifest-Version: 1.0\r\nCreated-By: Maven Archiver 3.4.0\r\nBuild-Jdk-Spec: 13\r\nImplementation-Title: demo\r\nImplementation-Version: 0.0.1-SNAPSHOT\r\nMain-Class: org.springframework.boot.loader.JarLauncher\r\nStart-Class: com.example.demo.DemoApplication\r\nSpring-Boot-Version: 2.2.2.RELEASE\r\nSpring-Boot-Classes: BOOT-INF/classes/\r\nSpring-Boot-Lib: BOOT-INF/lib/\r\n```\r\n', '刚毕业我就接触到了SpringBoot，当初感觉必成大器，第一印象就是内置了所有环境，打完包丢哪里都能跑起来，简化了tomcat Xml配置的一系列部署操作');
INSERT INTO `public` VALUES ('7', '超详细java笔记', '/user/aq407/超详细java笔记_covers.jpg', '编程', 'aq407', '2020-01-15 15:06:19', '### 一、基础知识：\r\n**1、JVM、JRE和JDK的区别：**\r\n\r\nJVM(Java Virtual Machine):java虚拟机，用于保证java的跨平台的特性。\r\n\r\n  java语言是跨平台，jvm不是跨平台的。\r\n\r\nJRE(Java Runtime Environment):java的运行环境,包括jvm+java的核心类库。\r\n\r\nJDK(Java Development Kit):java的开发工具,包括jre+开发工具\r\n\r\n \r\n\r\n### 2、环境变量path和classpath的作用是什么？\r\n\r\n(1)path是配置Windows可执行文件的搜索路径，即扩展名为.exe的程序文件所在的目录，\r\n\r\n   用于指定DOS窗口命令的路径。\r\n\r\n(2)Classpath是配置class文件所在的目录，用于指定类搜索路径，JVM就是通过它来寻找该类的class类文件的。\r\n\r\n \r\n\r\n### 3、变量有什么用？为什么要定义变量？什么时候用？\r\n\r\n答：变量的作用：用来存储数据。\r\n\r\n    为什么要定义变量：用来不断的存放同一类型的常量，并可以重复使用\r\n\r\n \r\n\r\n### 4、&和&&的区别?\r\n\r\n答：（1）&&会出现短路，如果可以通过第一个表达式判断出整个表达式的结果，则不继续后面表达式的运算；\r\n\r\n 只能操作boolean类型数据；\r\n\r\n    （2）&不会出现短路，将整个表达式都运算。既可以操作boolean数据还可以操作数。\r\n\r\n \r\n\r\n### 5、标示符命名规则：\r\n\r\n由数字(0-9)，大小写英文字母，以及_和$组成。\r\n\r\n不能以数字开头。\r\n\r\n不能使用关键字来自定义命名。\r\n\r\n \r\n\r\n### 6、数据类型：\r\n\r\n(1)基本数据类型(4类8种)：\r\n\r\n整数类型：byte、short、int、long\r\n\r\n浮点数类型：float、double\r\n\r\n字符类型：char\r\n\r\n布尔类型：boolean(ture false)\r\n\r\n(2)引用数据类型：\r\n\r\n类\r\n\r\n接口\r\n\r\n数组\r\n\r\n \r\n\r\n### 7、类型转换\r\n\r\n精度从高到低  double  float  long  int  short(char)  byte\r\n\r\n(1)自动类型转换  将一个低精度---à高精度\r\n\r\n(2)强制类型转换  将一个高精度---à低精度(精度会下降)\r\n\r\n \r\n\r\n### 8、java语言的三种技术架构\r\n\r\nJ2EE：企业版\r\n\r\n是为开发企业环境下的应用程序提供的一套解决方案。\r\n\r\n该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发。\r\n\r\nJ2SE：标准版\r\n\r\n是为开发普通桌面和商务应用程序提供的解决方案。\r\n\r\n该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发。\r\n\r\n比如Java版的扫雷。\r\n\r\nJ2ME：小型版\r\n\r\n是为开发电子消费产品和嵌入式设备提供的解决方案。\r\n\r\n该技术体系主要应用于小型电子消费类产品，如手机中的应用程序等。\r\n\r\n \r\n\r\n### 9、java的跨平台性：\r\n\r\n通过Java语言编写的应用程序在不同的系统平台上都可以运行。\r\n\r\n跨平台的原因：\r\n\r\n只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。\r\n\r\n由JVM来负责Java程序在该系统中的运行。\r\n\r\n \r\n\r\n### 10、有符号数据的表示法(次重点)\r\n\r\n原码，反码(原码取反)，补码(反码+1)。\r\n\r\n \r\n\r\n### 11、函数\r\n\r\n定义：函数就是定义在类中的具有特定功能的一段独立小程序。\r\n\r\n特点：\r\n\r\n定义函数可以将功能代码进行封装\r\n\r\n便于对该功能进行复用\r\n\r\n函数只有被调用才会被执行\r\n\r\n函数的出现提高了代码的复用性\r\n\r\n对于函数没有具体返回值的情况，返回值类型用关键字void表示，\r\n\r\n那么该函数中的return语句如果在最后一行可以省略不写。\r\n\r\n函数的应用两个明确：\r\n\r\n明确要定义的功能最后的结果是什么？\r\n\r\n明确在定义该功能的过程中，是否需要未知内容参与运算\r\n\r\n \r\n\r\n### 12、重载：\r\n\r\n概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。\r\n\r\n特点：与返回值类型无关，只看参数列表(参数类型以及参数个数)。\r\n\r\n好处：方便于阅读，优化了程序设计。\r\n\r\n \r\n\r\n### 13、数组：\r\n\r\n概念：同一种数据类型的集合。\r\n\r\n好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。\r\n\r\n \r\n\r\n### 14、内存结构：\r\n\r\n栈内存：用于存储局部变量，当数据使用完，所占空间会自动释放。\r\n\r\n堆内存：数组和对象，通过new建立的实例都存放在堆内存中。\r\n\r\n方法区：静态成员、构造函数、常量池、线程池\r\n\r\n本地方法区：window系统占用\r\n\r\n寄存器：用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。\r\n\r\n \r\n\r\n篇幅有限分成几篇发，喜欢这样文章的可以关注我，我会持续更新，你们的关注是我更新的动力！需要更多java学习资料的也可以私信我！\r\n\r\n祝关注我的人都：身体健康，财源广进，福如东海,寿比南山，早生贵子，从不掉发!', '这是我一个学霸朋友学习java时一点一点积累下来的笔记，分享给大家，希望能帮到刚学java或是想学java的你。绝不是什么网上复制粘贴下来的，内容都是很基础很重要的知识点！');
INSERT INTO `public` VALUES ('13', '第一次测试', '/user/aq407/第一次测试_covers.jpg', 'volvo', 'aq407', null, '```java\r\nSysout.out.println(\"hello world\");\r\n\r\n```\r\n\r\n![](user/aq407/太阳系.jpg)', '这是一次测试');
INSERT INTO `public` VALUES ('14', '第一次测试', '/user/aq407/第一次测试_covers.jpg', 'volvo', 'aq407', null, '```java\r\nSysout.out.println(\"hello world\");\r\n\r\n```\r\n\r\n![](user/aq407/太阳系.jpg)', '这是一次测试');
INSERT INTO `public` VALUES ('15', '第一次测试', '/user/aq407/第一次测试_covers.jpg', 'volvo', 'aq407', null, '```java\r\nSysout.out.println(\"hello world\");\r\n\r\n```\r\n\r\n![](user/aq407/太阳系.jpg)', '这是一次测试');
INSERT INTO `public` VALUES ('19', 'C++ 20 准备发布，C++ 23 提上议程', '/user/aq407/C++ 20 准备发布，C++ 23 提上议程_covers.png', '资源', 'aq407', '2020-02-21 16:23:45', '“在近期 ISO C++ 委员会会议上，我们完成了 C++ 20 委员会草案，并投票决定将国际标准草案（DIS，Draft International Standard）发送出去，以进行最终批准和发布”，帖子介绍：“在程序上，DIS 可能会被拒绝，但是由于我们的程序和过程，这种情况极不可能发生。这意味着 C++ 20 已经完成，并将在几个月后发布该标准。”\r\n\r\nC++ 20 是近十年来影响最大的一个版本，新的特性众多，包括：\r\n\r\n模组（Modules）\r\n协程（Coroutines）\r\n标准库 Concepts 的概念\r\n范围（range）\r\nconstexpr支持：new/ delete、dynamic_cast、try/ catch、虚拟\r\nconstexpr 向量和字符串\r\n计时：日历、时区支持\r\nstd::format\r\nstd::span\r\nstd::jthread\r\n预计这些新特性将会对开发者及 C++ 生态产生不小影响，特别是像协程这种巨大的变化。\r\n\r\n同时，在此次会议期间，委员会还通过了 C++ 23 计划，其中包括优先考虑模块化标准库、对协程、执行程序和网络的库支持。\r\n\r\n更加具体的内容可以查看原帖：\r\n\r\nhttps://www.reddit.com/r/cpp/comments/f47x4o/202002_prague_iso_c_committee_trip_report_c20_is', '根据 Reddit C++ 版块上的信息，C++ 20 已经正式通过委员会草案，这意味着 C++ 20 可以准备发布。');

-- ----------------------------
-- Table structure for public_img
-- ----------------------------
DROP TABLE IF EXISTS `public_img`;
CREATE TABLE `public_img` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `img` varchar(255) DEFAULT NULL,
  `public_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `public_id` (`public_id`),
  CONSTRAINT `public_img_ibfk_1` FOREIGN KEY (`public_id`) REFERENCES `public` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of public_img
-- ----------------------------

-- ----------------------------
-- Table structure for reply
-- ----------------------------
DROP TABLE IF EXISTS `reply`;
CREATE TABLE `reply` (
  `reply_id` bigint(11) NOT NULL AUTO_INCREMENT,
  `reply_content` varchar(255) DEFAULT NULL,
  `reply_userid` bigint(11) DEFAULT NULL,
  `reply_time` datetime DEFAULT NULL,
  `reply_publicid` bigint(11) DEFAULT NULL,
  `public_title` varchar(255) DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`reply_id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of reply
-- ----------------------------
INSERT INTO `reply` VALUES ('1', '<p>回复测试</p>\r\n', '1', '2020-01-14 05:53:29', null, 'Java 8 Stream 的终极技巧——Collectors 操作', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('2', '<p>回复测试over</p>\r\n', '2', '2020-01-14 06:04:33', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', null, '/img/22.jpg');
INSERT INTO `reply` VALUES ('3', '<p>这是回复内容鞍山的你来扫地啦家啊时间大</p>\r\n', '1', '2020-01-14 06:52:42', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('4', '<p>有点类似 Stream 先进行了 map 操作再进行 collect ：</p>\r\n', '1', '2020-01-14 06:56:50', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('5', '<p>该方法是先对元素使用 Function 进行再加工操作</p>\r\n', '1', '2020-01-14 07:02:21', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('6', '<p>这是回复内容鞍山的你来扫地啦家</p>\r\n', '1', '2020-01-14 07:05:51', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('7', '<p>test</p>\r\n', '1', '2020-01-14 09:10:03', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('8', '回复', null, '2020-01-22 14:50:14', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', null, null);
INSERT INTO `reply` VALUES ('9', '回复测试', '1', '2020-01-22 14:56:20', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', null, null);
INSERT INTO `reply` VALUES ('10', '在出差', '1', '2020-01-22 15:02:47', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', null, null);
INSERT INTO `reply` VALUES ('11', '额U按', '1', '2020-01-22 15:07:32', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', null, null);
INSERT INTO `reply` VALUES ('12', '看见好看', '1', '2020-01-22 15:23:07', '2', '第一次测试', null, null);
INSERT INTO `reply` VALUES ('13', '阿瑟大三大四', '1', '2020-01-22 15:29:06', '2', '第一次测试', null, null);
INSERT INTO `reply` VALUES ('14', '按时打撒', '1', '2020-01-22 15:31:37', '2', '第一次测试', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('15', null, '1', '2020-01-27 15:09:54', '1', null, 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('16', 'ajax回复测试', '1', '2020-01-27 15:12:41', '1', 'xds', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('17', '', '1', '2020-01-27 15:17:14', '5', 'Kotlin 1.4 和未来值得期待的地方', 'aq407', '/img/a.jpg');
INSERT INTO `reply` VALUES ('18', '回复测试', '2', '2020-04-14 14:07:04', '3', 'Java 8 Stream 的终极技巧——Collectors 操作', 'sai', '/img/22.jpg');
INSERT INTO `reply` VALUES ('19', '执行', '2', '2020-04-16 14:49:23', '1', 'xds', 'sai', '/img/22.jpg');
INSERT INTO `reply` VALUES ('20', 'asdasd', '1', '2020-04-16 15:12:54', '1', 'xds', 'aq407', '/img/a.jpg');

-- ----------------------------
-- Table structure for sign_up
-- ----------------------------
DROP TABLE IF EXISTS `sign_up`;
CREATE TABLE `sign_up` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `signtime` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `level` varchar(10) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=104 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sign_up
-- ----------------------------
INSERT INTO `sign_up` VALUES ('1', 'aq407', '525432', '2020-01-09 13:01:15', '929193338@qq.com', 'user', '/img/a.jpg');
INSERT INTO `sign_up` VALUES ('2', 'sai', '123456', '2020-01-19 13:01:15', '929193338@qq.com', 'user', '/img/22.jpg');
INSERT INTO `sign_up` VALUES ('3', 'test', '123456', '2020-04-17 09:14:51', 'test@email.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('5', 'test3', '654321', '2020-04-17 09:38:53', 'test@email.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('10', 'test11', '123456', '2020-04-17 16:01:35', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('25', 'luozhuo', '123456', '2020-04-19 09:27:32', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('26', 'aq47', '333333', '2020-04-19 09:48:11', '1599407173@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('27', 'hzw', '525432', '2020-04-20 09:20:46', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('28', 'user1', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('29', 'user2', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('30', 'user3', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('31', 'user4', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('33', 'user5', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('35', 'user6', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('36', 'user7', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('37', 'user8', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('38', 'user9', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('39', 'user10', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('40', 'user11', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('41', 'user12', '123456', '2020-04-22 09:31:41', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('42', 'zxc', '123456', '2020-04-23 05:44:10', '929193338@qq.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('43', '007', '123456', '2020-04-24 09:34:48', '123456', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('44', 'admin', 'admin', null, '929193338@qq.com', 'admin', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('45', '>\"\'><script>alert(415)</script>', '>\"\'><script>alert(415)</script>', '2020-04-28 08:49:05', '>\"\'><script>alert(415)</script>', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('46', 'WFXSSProbe\'\")/>', '', '2020-04-28 08:49:06', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('47', 'WFXSSProbe', '', '2020-04-28 08:49:08', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('48', 'AB', '', '2020-04-28 08:49:09', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('49', 'WF\'SQL\"Probe;A--B', '', '2020-04-28 08:49:12', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('50', '\'\"', '', '2020-04-28 08:49:13', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('51', 'ProbePhishing', '', '2020-04-28 08:49:14', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('52', '#&<(,+\">;', '', '2020-04-28 08:49:16', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('53', '|id', '', '2020-04-28 08:49:17', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('54', '|ls -a1F', '', '2020-04-28 08:49:17', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('55', 'ls', '', '2020-04-28 08:49:17', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('56', '&&id', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('57', '&&ls -a1F', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('58', '\0', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('59', '|vol', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('60', '||id', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('61', '\"|wget http://127.0.0.1:51787/AppScanMsg.html?varId=621|echo \"', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('62', '\' and \'f\'=\'f', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('63', '\' and \'f\'=\'f\' -- ', '', '2020-04-28 08:49:18', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('64', '||ls -a1F', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('65', '\' and \'f\'=\'f\') -- ', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('66', '%\' and \'f%\'=\'f', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('67', '\' | \'id', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('68', '&&vol', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('69', '\'|wget http://127.0.0.1:51787/AppScanMsg.html?varId=626|echo \'', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('70', '\' + ltrim(\'\') + \'', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('71', '\' | \'ls -a1F', '', '2020-04-28 08:49:19', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('72', '\" | \"id', '', '2020-04-28 08:49:21', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('73', '(select )', '', '2020-04-28 08:49:21', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('74', '||vol', '', '2020-04-28 08:49:21', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('75', '\' || \'\' || \'', '', '2020-04-28 08:49:21', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('76', '\" | \"ls -a1F', '', '2020-04-28 08:49:21', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('77', '|wget http://127.0.0.1:51787/AppScanMsg.html?varId=634|echo ;', '', '2020-04-28 08:49:21', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('78', '\'', '', '2020-04-28 08:49:22', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('79', '\' | \'vol', '', '2020-04-28 08:49:22', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('80', 'id', '', '2020-04-28 08:49:22', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('81', 'ls -a1F', '', '2020-04-28 08:49:22', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('82', 'AVAK$(RETURN_CODE)OS', '', '2020-04-28 08:49:23', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('83', '\"|echo -e \"GET /AppScanMsg.html?varId=643 HTTP/1.0\\r\\n\\r\\n\" | nc 127.0.0.1 51787|echo \"', '', '2020-04-28 08:49:23', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('84', '\\\'', '', '2020-04-28 08:49:23', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('85', '\" | \"vol', '', '2020-04-28 08:49:24', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('86', ';id\0', '', '2020-04-28 08:49:24', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('87', ';id\0', '', '2020-04-28 08:49:24', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('88', '\'|echo -e \"GET /AppScanMsg.html?varId=646 HTTP/1.0\\r\\n\\r\\n\" | nc 127.0.0.1 51787|echo \'', '', '2020-04-28 08:49:24', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('89', '\'|echo -e \"GET /AppScanMsg.html?varId=646 HTTP/1.0\\r\\n\\r\\n\" | nc 127.0.0.1 51787|echo \'', '', '2020-04-28 08:49:24', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('90', ';vol\0', '', '2020-04-28 08:49:25', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('91', '\"', '', '2020-04-28 08:49:25', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('92', 'bgprobeum00000B', '', '2020-04-28 08:49:25', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('93', '|echo -e \"GET /AppScanMsg.html?varId=647 HTTP/1.0\\r\\n\\r\\n\" | nc 127.0.0.1 51787|echo ', '', '2020-04-28 08:49:25', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('94', '\\\"', '', '2020-04-28 08:49:26', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('95', 'res.end(require(\'fs\').readdirSync(\'.\').toString())', '', '2020-04-28 08:49:26', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('96', '\'Abgprobeum00000B', '', '2020-04-28 08:49:26', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('97', ';curl http://127.0.0.1:51787/AppScanMsg.html?varId=649;', '', '2020-04-28 08:49:26', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('98', ')', '', '2020-04-28 08:49:27', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('99', '\rAppScanHeader: AppScanValue/1.2-654\rSecondAppScanHeader: whatever', '', '2020-04-28 08:49:27', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('100', 'res.end(require(\'fs\').readdirSync(\'..\').toString())', '', '2020-04-28 08:49:27', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('101', '\"Abgprobeum00000B', '', '2020-04-28 08:49:27', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('102', '\r\nAppScanHeader: AppScanValue/1.2-665\r\nSecondAppScanHeader: whatever', '', '2020-04-28 08:49:28', 'test@altoromutual.com', 'user', '/img/default.jpg');
INSERT INTO `sign_up` VALUES ('103', '\"\'', '', '2020-04-28 08:49:29', 'test@altoromutual.com', 'user', '/img/default.jpg');
